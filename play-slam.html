<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-button/paper-button.html">
<link href="../deck-of-cards/example/example.css" rel="stylesheet" type="text/css">
<script src="../deck-of-cards/dist/deck.js"></script>
<!--
  `<play-slam></play-slam>` #Slam 

A game of cards I played with my daughter's. We are making this game and therefore we are making the rules the same as we played then.

Still freeze cleaners eBay and changed the rules of Italy 
  @demo demo.html
-->
<dom-module id="play-slam">
  <template>
    
    <style>
    :host {
      height:600px;
      display:block;
      background-color:#45a173;
      font-family: 'Open Sans', sans-serif;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      overflow: hidden;
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }
    </style>
    <div id="container">[[count]]</div>
    <template is="dom-if" if="[[setReady]]">
      <paper-button on-tap="isReady">Ready</paper-button>
    </template>
  </template>
</dom-module>
<script>
  Polymer({
    is: "play-slam",
    ready: function(){
      var prefix = Deck.prefix
      var transform = prefix('transform')
      var translate = Deck.translate
      this.deck = Deck()
      /* Game State */
      var gP0Cards = [[],[],[],[],[]]
      var gTable =   [[],[],   [],[]]
      var gP1Cards = [[],[],[],[],[]]
      
      this.deck.mount(this.$.container)
      this.play(gP0Cards,gP1Cards,gTable,this.deck)
    },
    play: function(p0Cards, p1Cards, middle, deck){
      deck.queue(function (next) {
        deck.flip()
        deck.fan()
        deck.flip()
        deck.shuffle()
        next()
      })
      deck.queue(function (next) {
        deck.cards.forEach(function (card,i) {
          var hand 
          var time = 0
          var onComplete = function (){}
          if (card.pos < 15) {
            hand = 0
          } else if (card.pos < 30) {
            hand = 1
          } else if (card.pos < 40) {
            hand = 0
          } else if (card.pos < 51) {
            hand = 1
          } else {
            hand = 0
            var onComplete = function (){
              next()
            }
          }
            
          card.animateTo({
            delay: 40,
            duration: 500,
            ease: 'quartOut',
            x: ((2/4) * window.innerWidth - window.innerWidth / 2),
            y: ((hand/1) * window.innerHeight - window.innerHeight / 2),
            onComplete: onComplete,
          })
        })
      })
      var that = this
      var plan = [
        [0,1], [1,0], [2,0], [3,0], [4,0],
        [1,1], [2,0], [3,0], [4,0],
        [2,1], [3,0], [4,0],
        [3,1], [4,0],
        [4,1],
      ]
      var topCards = []
      var timing = 0
      deck.queue(function (next) {
        deck.cards.forEach(function (card,i) {
          var c = card.suit * 13 + card.rank
          var theX
          var theY
          var yShift = 0
          var onComplete = function (){}
          card.setSide('back')
          if (card.pos < 15) {
            if (plan[card.pos][1]) {
              onComplete  = function () {
                deck.cards[i].setSide('front')
              }
            }
            theX = 4 - plan[card.pos][0]
            theY = 0
            p0Cards[theX].push(c)
            card.z = p0Cards[theX].length
            yShift = p0Cards[theX].length * -10
          } else if (card.pos < 30) {
            if (plan[card.pos-15][1]) {
              onComplete  = function () {
                deck.cards[i].setSide('front')
              }
            } 
            theX = plan[card.pos-15][0]
            timing = 15
            theY = 2
            p1Cards[theX].push(c)
            card.z = p1Cards[theX].length
            yShift = p1Cards[theX].length * 10
          } else if (card.pos < 40) {
            middle[0].push(c)
            card.z = middle[0].length
            timing = 11
            theX = 4
            theY = 1
          } else if (card.pos < 50){
            middle[3].push(c)
            card.z = middle[3].length
            theX = 0
            theY = 1
          } else if (card.pos == 50) {
            timing = 11
            middle[0].push(c)
            card.z = middle[0].length
            topCards.push(i)
            theX = 0
            theY = 1
          } else {
            middle[3].push(c)
            card.z = middle[3].length
            topCards.push(i)
            theX = 4
            theY = 1 
            onComplete = function () {
              setTimeout(function () {
                that.allowPlay()
                that.count = 3
              }, 2000)
              setTimeout(function () {
                that.count = 2
              }, 3000)
              setTimeout(function () {
                that.count = 1
              }, 4300)
              setTimeout(function () {
                that.count = ""
                that.flipTheCards(topCards)
              }, 5800)
            }
          }
          
          card.animateTo({
            delay: 500 + (card.pos- timing) * 75,
            duration: 500 + card.pos * 27,
            ease: 'quartOut',
            x: ((theX/4) * window.innerWidth - window.innerWidth / 2) * .7,
            y: (((theY/2) * window.innerHeight - window.innerHeight / 2) *.6) + yShift - 30,
            onComplete: onComplete,
          })
        })
        that.p0 = p0Cards
        that.middle = middle
        that.p1 = p1Cards
        next()
      })
    },
    isinArray: function(ar,findThis) {
      var index = -1
      ar.forEach(function (arr,i) {
        if (arr.indexOf(findThis) !== -1) {
          index = i
        }
      })
      return index
    },
    isOnTop: function (ar,test) { 
      var onTop = -1
      ar.forEach(function (arr,i) {
        if (arr.length && arr[arr.length - 1] === test) {
          onTop = i
        }
      })
      return onTop
    },
    isReady: function(){
      this.flipTheCards()
    },
    flipTheCards: function(){
      var that = this
      // find top cards for middle pile
      this.deck.cards.forEach(function (card, i) {
        var c = card.suit * 13 + card.rank
        function moveCard(from, to ,fromX ,toX){
          var onComplete  = function () {
            card.setSide('front')
            card.z = that.middle[to].length
            that.middle[to].push(that.middle[from].pop())
            that.set("middle", that.middle)
            that.allowPlay()
            that.set("setReady", true)
          }  
          var halfWay = (fromX + toX) / 2
          card.animateTo({
            delay: 50,
            duration: 500,
            ease: 'quartOut',
            x: ((halfWay/4) * window.innerWidth - window.innerWidth / 2) * .7,
            y: (((1/2) * window.innerHeight - window.innerHeight / 2) *.6) - 30,
            onComplete: onComplete,
          })
          card.animateTo({
            delay: 550,
            duration: 500,
            ease: 'quartOut',
            x: ((toX/4) * window.innerWidth - window.innerWidth / 2) * .7,
            y: (((1/2) * window.innerHeight - window.innerHeight / 2) *.6) - 30,
            onComplete: function() {
              that.allowPlay()
            },
          })
        }
        if (that.middle[0][that.middle[0].length - 1] === c) {
          moveCard(0,1,0,1)
        }
        if (that.middle[3][that.middle[3].length - 1] === c) {
          moveCard(3,2,4,3)
        }
      })
    },
    getHeight: function(ar,c){
      var arrIndex = this.isinArray(c)
      if (arrIndex !== -1) {
        return ar[arrIndex].indexOf(c)
      } else {
        return -1
      }
    },
    allowPlay: function(){
      var that =   this
      var p0 =     this.p0
      var middle = this.middle 
      var p1 =     this.p1 
      this.deck.cards.forEach(function (card, i) {
        var c = card.suit * 13 + card.rank
        card.$el.style.zIndex = card.z = that.getHeight(p0.concat(middle, p1),c)
        
        if (that.isinArray(p0, c) !== -1 || that.isinArray(p1, c) !== -1) {
          if (that.isOnTop(p0, c) !== -1 || that.isOnTop(p1, c) !== -1 ) {
            if (card.side != "front") {
              card.enableFlipping()
            } else {
              card.disableFlipping()
            }
            card.enableDragging()
            if (!card.addedEL) {
              card.addedEL = that.drop(c)
              card.$el.addEventListener('mouseup', card.addedEL)
              card.$el.addEventListener('touchend', card.addedEL)
            }
          } else {
            if (typeof card.addedEL === "function") {
              card.disableDragging()
              card.disableFlipping()
              card.$el.removeEventListener("mouseup",card.addedEL)
              card.$el.removeEventListener("touchend",card.addedEL)
              delete(card.addedEL)
            }
          }
        } else {
          if (typeof card.addedEL === "function") {
            card.disableDragging()
            card.disableFlipping()
            card.$el.removeEventListener("mouseup",card.addedEL)
            card.$el.removeEventListener("touchend",card.addedEL)
            delete(card.addedEL)
          }
        }
      })
      // update game
      console.log(p0)
      console.log(middle)
      console.log(p1)
      this.p0 =     p0
      this.middle = middle
      this.p1 =     p1
    },
    place: function(x,y,card){
        var p0 = this.p0
        var middle = this.middle
        var p1 = this.p1
      /*
        Once a player has got rid of all of there cards 
        by moving them to the middle piles (A || B) 
        than go in to grab mode
        see getPile for map
        You can only take 'from' the top of the piles (pop)
        p0 & p1:
        can move amongst themselves but not across to the other set if:
          [ is empty || top card is not turned over yet || it contains the same value ]
        can move to A or B if 
        value of the moving card is +1 or -1 of the card it would land on
      
       */
      var player
      var to = this.getPile(x,y)
      var fromP0 = this.isinArray(p0,card)
      var fromP1 = this.isinArray(p1,card)
      var from
      var move = false
      var notRemove = -1
      var i
      if (fromP1 !== -1) {
        from = "56789"[fromP1]
        if (from !== to) {
          i = "56789".indexOf(to)
          if (i !== -1) {
            if (p1[i].length == 0 || (card % 13) == ((p1[i][p1[i].length - 1]) % 13)) {
              p1[i].push(p1[fromP1].pop())
            }
          }
        }
        player = 1
      } else if (fromP0 !== -1) {
        from = "01234"[fromP0]
        if (from !== to) {
          i = "01234".indexOf(to)
          if (i !== -1) {
            if (p0[i].length == 0 || (card % 13) == ((p0[i][p0[i].length - 1]) % 13)) {
              p0[i].push(p0[fromP0].pop())
            }
          }
        }
        player = 0
      }
      // p0 = this.removeCard(p0,card)
      // middle = this.removeCard(middle,card)
      if (from && to !== from) {
        if (card) {
          switch (to) {
           case "A":
             var topCardA = middle[1][middle[1].length - 1]
             if ((card % 13) == ((topCardA + 1) % 13) || (card % 13) == ((topCardA - 1) % 13)) { 
               middle[1].push(card)
               move = true
             }
             break
           case "B":
             var topCardB = middle[2][middle[2].length - 1]
             if ((card % 13) == ((topCardB + 1) % 13) || (card % 13) == ((topCardB - 1) % 13)) { 
               middle[2].push(card)
               move = true
             }
             break
          }
        }  
        if (move) {
          if (player == 1) {
            p1 = this.removeCard(p1,card)
          } else {
            p0 = this.removeCard(p0,card)
          }
        }
        this.p0 = p0
        this.middle = middle
        this.p1 = p1
        this.allowPlay() 
      }
    },
    removeCard: function(ar,thisOne, notRemove) {
      return ar.reduce(function (accumulator, currentValue) {
        accumulator.push(currentValue.reduce(function (accumulator, currentValue, cindex) {
          if (currentValue !== thisOne) {
            accumulator.push(currentValue)
          }
          return accumulator
        },[]))
        return accumulator
      },[])
    },
    drop: function(picked){
      var that = this
      return function(event) {
        that.place(event.x,event.y, picked)
      }
    },
    getPile: function(x,y){
      var theBoard = [
        "01234",
        "aA|Bb",
        "56789"
      ]
      var theX 
      if (x < ( (1/4) * window.innerWidth) * .7) {
        theX = 0
      } else if (x < ( (2/4) * window.innerWidth) * .7) {
        theX = 1
      } else if (x < ( (3/4) * window.innerWidth) * .7) {
        theX = 2
      } else if (x < ( (4/4) * window.innerWidth) * .7) {
        theX = 3
      } else if (x < ( (5/4) * window.innerWidth) * .7) {
        theX = 4
      } 
      var theY
      if (y < (((1/2) * window.innerHeight) *.6)) {
        theY = 0
      } else if (y < (((2/2) * window.innerHeight) *.6)) {
        theY = 1
      } else if (y < (((3/2) * window.innerHeight) *.6)) {
        theY = 2
      } 
      
      return theBoard[theY][theX]
    },
  })
</script>
