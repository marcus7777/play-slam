<link rel="import" href="../polymer/polymer.html">
<link href="../deck-of-cards/example/example.css" rel="stylesheet" type="text/css">
<script src="../deck-of-cards/dist/deck.js"></script>
<!--
  `<play-slam></play-slam>` #Slam 

A game of cards I played with my daughter's. We are making this game and therefore we are making the rules the same as we played then.

Still freeze cleaners eBay and changed the rules of Italy 
  @demo demo.html
-->
<dom-module id="play-slam">
  <template>
    
    <style>
    :host {
      height:600px;
      display:block;
      background-color:#45a173;
      font-family: 'Open Sans', sans-serif;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      overflow: hidden;
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }
    </style>
    <div id="container"></div>
  </template>
</dom-module>
<script>
  Polymer({
    is: "play-slam",
    ready: function(){
      var prefix = Deck.prefix
      var transform = prefix('transform')
      var translate = Deck.translate
      var $container = this.$.container
      var deck = Deck()
      /* Game State */
      var gP0Cards = [[],[],[],[],[]]
      var gTable =   [[],[],   [],[]]
      var gP1Cards = [[],[],[],[],[]]
      
      deck.mount($container)
      
      this.play(gP0Cards,gP1Cards,gTable,deck)
    },
    play: function(p0Cards, p1Cards, middle, deck){
      
      deck.flip()
      deck.fan()
      deck.flip()
      deck.shuffle()
      
      var that = this
      var plan = [
        [0,1], [1,0], [2,0], [3,0], [4,0],
        [1,1], [2,0], [3,0], [4,0],
        [2,1], [3,0], [4,0],
        [3,1], [4,0],
        [4,1],
      ]
      
      deck.queue(function (next) {
        deck.cards.forEach(function (card, i) {
          var theX
          var theY
          var yShift = 0
          var onComplete = function (){}
          card.setSide('back')
          if (card.pos < 15) {
            if (plan[card.pos][1]) {
              onComplete  = function () {
                deck.cards[i].setSide('front')
              }
            }
            theX = 4 - plan[card.pos][0]
            theY = 0
            p0Cards[theX].push(i)
            yShift = p0Cards[theX].length * -10
          } else if (card.pos < 30) {
            if (plan[card.pos-15][1]) {
              onComplete  = function () {
                deck.cards[i].setSide('front')
              }
            } 
            theX = plan[card.pos-15][0]
            theY = 2
            p1Cards[theX].push(i)
            yShift = p1Cards[theX].length * 10
          } else if (card.pos < 40) {
            middle[0].push(i)
            theX = 4
            theY = 1
          } else if (card.pos < 50){
            middle[3].push(i)
            theX = 0
            theY = 1
          } else if (card.pos == 50) {
            middle[1].push(i)
            theX = 1
            theY = 1
          } else {
            middle[2].push(i)
            theX = 3
            theY = 1 
            onComplete = function () {
              that.allowPlay(p0Cards,p1Cards,middle,deck)
            }
          }     
          card.animateTo({
            delay: 500 + (52 - card.pos) * 75,
            duration: 500 + card.pos * 27,
            ease: 'quartOut',
            x: ((theX/4) * window.innerWidth - window.innerWidth / 2) * .7,
            y: (((theY/2) * window.innerHeight - window.innerHeight / 2) *.6) + yShift - 30,
            onComplete: onComplete,
          })
        })
        next()
      })
    },
    isinArray: function(ar,findThis) {
      var index = -1
      ar.forEach(function (arr,i) {
        if (arr.indexOf(findThis) !== -1) {
          index = i
        }
      })
      return index
    },
    isOnTop: function (ar,test) { 
      var onTop = false
      ar.forEach(function (arr,i) {
        if (arr.length && arr[arr.length - 1] == test) {
          onTop = true
        }
      })
      return onTop
    }, 
    allowPlay: function(p0,p1,middle,deck){
      var that = this
      deck.cards.forEach(function (card, i) {
        if (that.isinArray(p0, i) !== -1) {
          // card.enableDragging()
          // card.enableFlipping()
        } else if (that.isinArray(p1, i) !== -1) {
          if (card.side != "front") {
            card.enableFlipping()
          } else {
            card.disableFlipping()
          }
          if (that.isOnTop(p1,i)) {
            card.enableDragging()
            card.$el.addEventListener('mouseup', that.drop(i,that))
            card.$el.addEventListener('touchend', that.drop(i,that))
          } else {
            card.$el.removeEventListener('mouseup', that.drop(i,that))
            card.$el.removeEventListener('touchend', that.drop(i,that))
          }
          // card.enableFlipping()
        } else {
          card.disableDragging()
          card.disableFlipping()
          if (that.isOnTop(middle,i)) {
            card.$el.removeEventListener('mouseup', that.drop(i,that))
            card.$el.removeEventListener('touchend', that.drop(i,that))
          }
          
          if (middle[1].indexOf(i) !== -1 || middle[2].indexOf(i) !== -1) {
            card.setSide('front')
            card.$el.removeEventListener('mouseup', that.drop(i,that))
            card.$el.removeEventListener('touchend', that.drop(i,that))
          }
        }
      })
      // update game
      this.p0 = p0
      this.p1 = p1
      console.log(p1)
      this.middle = middle
      this.deck = deck
    },
    place: function(x,y,card,deck,p0,p1,middle){
      /*
        Once a player has got rid of all of there cards 
        by moving them to the middle piles (A || B) 
        than go in to grab mode
        see getPile for map
        You can only take 'from' the top of the piles (pop)
        p0 & p1:
        can move amongst themselves but not across to the other set if:
          [ is empty || top card is not turned over yet || it contains the same value ]
        can move to A or B if 
        value of the moving card is +1 or -1 of the card it would land on
      
       */
      var player = 1
      var to = this.getPile(x,y)
      var fromP0
      var fromP1
      var from
      if ((fromP1 = this.isinArray(p1,card)) !== -1) {
        from = "56789"[fromP1]
      } else if ((fromP0 = this.isinArray(p0,card)) !== -1) {
        from = "01234"[fromP0]
      }
      var move = false
      var notRemove = -1
      // p0 = this.removeCard(p0,card)
      // middle = this.removeCard(middle,card)
      if (from && to !== from) {
        if (card) {
          switch (to) {
            case "0":
              if (player == 0) {
                p0[0].push(card)
                notRemove = 0
                move = true
              }
              break
            case "1":
              if (player == 0) {
                p0[1].push(card)
                notRemove = 1
                move = true
              }
              break
            case "2":
              if (player == 0) {
                notRemove = 2
                p0[2].push(card)
                move = true
              }
              break
            case "3":
              if (player == 0) {
                notRemove = 3
                p0[3].push(card)
                move = true
              }
              break
            case "4":
              if (player == 0) {
                notRemove = 4
                p0[4].push(card)
                move = true
              }
              break
            case "5":
              if (player == 1) {
                notRemove = 0
                p1[0].push(card)
                move = true
              }
              break
            case "6":
              if (player == 1) {
                notRemove = 1
                p1[1].push(card)
                move = true
              }
              break
            case "7":
              if (player == 1) {
                notRemove = 2
                p1[2].push(card)
                move = true
              }
              break
            case "8":
              if (player == 1) {
                notRemove = 3
                p1[3].push(card)
                move = true
              }
              break
            case "9":
              if (player == 1) {
                notRemove = 4
                p1[4].push(card)
                move = true
             }
             break
           case "A":
             middle[1].push(card)
             move = true
             break
           case "B":
             middle[2].push(card)
             move = true
             break
          }
        }  
        if (move) {
          p1 = this.removeCard(p1,card,notRemove)
        }
        this.allowPlay(p0,p1,middle,deck) 
      }
    },
    removeCard: function(ar,thisOne, notRemove) {
      return ar.reduce(function (accumulator, currentValue) {
        accumulator.push(currentValue.reduce(function (accumulator, currentValue, cindex) {
          if (currentValue !== thisOne && cindex !== notRemove) {
            accumulator.push(currentValue)
          }
          return accumulator
        },[]))
        return accumulator
      },[])
    },
    drop: function(picked,that){
      return function(event) {
        console.log(
          event.x,
          event.y,
          picked
        )
        that.place(event.x,event.y, picked,that.deck,that.p0,that.p1,that.middle)
      }
    },
    getPile: function(x,y){
      var theBoard = [
        "01234",
        "aA|Bb",
        "56789"
      ]
      var theX 
      if (x < ( (1/4) * window.innerWidth) * .7) {
        theX = 0
      } else if (x < ( (2/4) * window.innerWidth) * .7) {
        theX = 1
      } else if (x < ( (3/4) * window.innerWidth) * .7) {
        theX = 2
      } else if (x < ( (4/4) * window.innerWidth) * .7) {
        theX = 3
      } else if (x < ( (5/4) * window.innerWidth) * .7) {
        theX = 4
      } 
      var theY
      if (y < (((1/2) * window.innerHeight) *.6)) {
        theY = 0
      } else if (y < (((2/2) * window.innerHeight) *.6)) {
        theY = 1
      } else if (y < (((3/2) * window.innerHeight) *.6)) {
        theY = 2
      } 
      
      return theBoard[theY][theX]
    },
  })
</script>
